using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace LoRaWAN
{
    /// <summary>
    /// Represents a buffer for LoRaWAN messages containing byte data.
    /// </summary>
    public class sBuffer
    {
        // Byte array to store the payload of the LoRaWAN message.
        public byte[] Data;

        // Counter to track the number of bytes in the LoRaWAN buffer.
        public byte Counter;
    }


    /// <summary>
    /// Represents session data for LoRaWAN communication.
    /// </summary>
    public class sLoRaSession
    {
        // Network Session Key: Key used for securing the communication between the end device and the network server.
        public byte[] NwkSKey;

        // Application Session Key: Key used for securing the application-level data exchanged between the end device and the application server.
        public byte[] AppSKey;

        // Device Address: Unique address assigned to the end device within the LoRaWAN network.
        public byte[] DevAddr;

        // Frame Counter: Counter used to keep track of the number of frames transmitted by the end device.
        public uint FrameCounter;
    }


    /// <summary>
    /// Represents parameters for Over-the-Air Activation (OTAA) in LoRaWAN.
    /// </summary>
    public class sLoRaOTAA
    {
        // Device EUI: Unique identifier assigned to the end device.
        public byte[] DevEUI;

        // Application EUI: Unique identifier assigned to the application server.
        public byte[] AppEUI;

        // Application Key: Key shared between the end device and the network server for secure communication.
        public byte[] AppKey;

        // Device Nonce: Random number generated by the end device during OTAA to ensure unique join requests.
        public byte[] DevNonce;

        // Application Nonce: Random number generated by the network server during OTAA to ensure freshness and uniqueness of session keys.
        public byte[] AppNonce;

        // Network Identifier: Identifier for the LoRaWAN network.
        public byte[] NetID;
    }


    /// <summary>
    /// Represents a LoRaWAN message.
    /// </summary>
    public class sLoRaMessage
    {
        // MAC Header: Header containing control information for the LoRaWAN message.
        public byte MACHeader;

        // Device Address: Address of the end device associated with the message.
        public byte[] DevAddr = new byte[4];

        // Frame Control: Control information for the LoRaWAN frame.
        public byte FrameControl;

        // Frame Counter: Counter to track the number of frames sent or received.
        public uint FrameCounter;

        // Frame Port: Port number associated with the payload of the LoRaWAN message.
        public byte FramePort;

        // Frame Options: Options included in the LoRaWAN frame.
        public byte[] FrameOptions = new byte[15];

        // Message Integrity Code: Code used for message integrity verification.
        public byte[] MIC = new byte[4];

        // Message Direction: Direction of the LoRaWAN message (uplink or downlink).
        public byte Direction;
    }


    /// <summary>
    /// Represents settings for the end device (mote).
    /// </summary>
    public class sSettings
    {
        // Confirm: Indicates whether the transmission is confirmed or unconfirmed.
        //          0x00: Unconfirmed, 0x01: Confirmed
        public byte Confirm;

        // Mote Port: Port number for communication with the application server.
        //            Range: 1-223
        public byte Mport;

        // Mote Class: Class of the end device (Class A or Class C).
        //             0x00: Class A, 0x01: Class C
        public byte MoteClass;

        // Data Rate for Transmission: Data rate used for transmitting data.
        public byte DatarateTx;

        // Data Rate for Reception: Data rate used for receiving data.
        public byte DatarateRx;

        // Transmission Channel: Channel used for transmitting data.
        public byte ChannelTx;

        // Reception Channel: Channel used for receiving data.
        public byte ChannelRx;

        // Channel Hopping: Indicates whether channel hopping is enabled or not.
        //                  0x00: No hopping, 0x01: Hopping
        public byte ChannelHopping;

        // Transmit Power: Power level used for transmitting data.
        //                 Range: 0x00 to 0x0F
        public byte TransmitPower;
    }


    /// <summary>
    /// Enumeration of LoRaWAN channels.
    /// </summary>
    public enum CHANNEL
    {
        CH0 = 0,    // Channel 0
        CH1 = 1,    // Channel 1
        CH2 = 2,    // Channel 2
        CH3 = 3,    // Channel 3
        CH4 = 4,    // Channel 4
        CH5 = 5,    // Channel 5
        CH6 = 6,    // Channel 6
        CH7 = 7,    // Channel 7
        CHRX2 = 8,  // RX2 Channel: Channel used for receiving downlink messages.
        MULTI = 20  // Multi-channel: Custom channel used for specific purposes.
    }


    /// <summary>
    /// Enumeration defining LoRa data rates.
    /// </summary>
    public enum DATA_RATES : byte
    {
        SF12BW125 = 0x00,
        SF11BW125 = 0x01,
        SF10BW125 = 0x02,
        SF9BW125 = 0x03,
        SF8BW125 = 0x04,
        SF7BW125 = 0x05,
        SF7BW250 = 0x06
    }


    /// <summary>
    /// Enumeration of transmitter pins.
    /// </summary>
    public enum TRANSMITTER_PINS
    {
        RFO_PIN = 0,        // RFO Pin: Output pin used for RF output.
        PA_BOOST_PIN = 1    // PA Boost Pin: Output pin used for power amplifier boost.
    }


    /// <summary>
    /// Enumeration of device classes.
    /// </summary>
    public enum DEVICE_CLASS_TYPES
    {
        CLASS_A,    // Class A: One of the device classes defined in LoRaWAN, characterized by its asynchronous communication mode.
        CLASS_C     // Class C: One of the device classes defined in LoRaWAN, characterized by its continuous communication mode.
    }


    /// <summary>
    /// Enumeration of reception modes. Device actively listens for incoming connections.
    /// </summary>
    public enum RX_TYPES
    {
        NO_RX,  // No RX: Indicates that there is no reception.
        NEW_RX  // New RX: Indicates the start of a new reception.
    }


    /// <summary>
    /// Enumeration of acknowledgment modes.
    /// </summary>
    public enum ACK_TYPES
    {
        NO_ACK, // No Acknowledgment: Indicates that there is no acknowledgment for a transmitted message.
        NEW_ACK // New Acknowledgment: Indicates the reception of a new acknowledgment for a transmitted message.
    }


    /// <summary>
    /// Enumeration of message types.
    /// </summary>
    public enum MESSAGE_TYPES
    {
        MSG_UP, // Upstream Message: Message transmitted from an end device to the network server.
        MSG_ACK // Acknowledgment Message: Message sent as an acknowledgment in response to a received message.
    }
}
